language: russian

## Цель плана

Гарантировать, что **внутри библиотеки невозможно** получить некорректное состояние сцены/документа: единые инварианты (уникальные `NodeId`, ровно один фон, допустимые числовые диапазоны) соблюдаются **всегда** и одинаково для всех источников данных (JSON, `SceneSnapshot`, программная сборка). Устранить класс проблем “разные входы → разные гарантии”, обеспечить симметрию сериализации/десериализации и устойчивость к повреждённым данным.

---

## План задач

### ☑ 1) Ввести единый шлюз построения доменной модели (валидация + канонизация)

**Что делаем:** создаём единственное место, через которое формируется валидная доменная модель `Scene/Document`.
**Почему:** иначе правила расползаются между JSON/`SceneSnapshot`, и “дырки” появляются снова.
**Где:** новый модуль `lib/src/model/scene_builder.dart`; подключения в `lib/src/model/document.dart` и `lib/src/serialization/scene_codec.dart`.
**ТЗ:**

* Реализовать `SceneBuilder.buildFromSnapshot(SceneSnapshot raw)` и `SceneBuilder.buildFromJson(Map<String,Object?> rawJson)` (или аналогичный вход).
* Оба метода обязаны вызывать общий внутренний конвейер: `canonicalizeAndValidate(raw)`.
* Конвейер выполняется строго в порядке:

  1. структурная проверка инвариантов (задачи 2, 3),
  2. канонизация (задача 4),
  3. проверка чисел/границ (задача 6),
  4. сборка доменной модели.
* Любые существующие прямые пути создания доменной модели переводим на вызов `SceneBuilder` (прямые конструкторы/функции помечаем внутренними).
  **Критерии приёмки:**
* Невозможно создать доменную модель минуя `SceneBuilder`.

---

### ☑ 2) Сделать уникальность `NodeId` обязательным инвариантом на входе

**Что делаем:** при любом импорте/сборке запрещаем дубликаты `NodeId`.
**Почему:** дубликаты приводят к “перезаписи” в картах/локаторах и неустойчивому поведению, которое в release может быть “тихим”.
**Где:** логика проверки в `scene_builder.dart`; удаление/перенос слабых проверок из `lib/src/model/document.dart` и `lib/src/serialization/scene_codec.dart`.
**ТЗ:**

* В `canonicalizeAndValidate` реализовать проверку “`NodeId` уникальны по всей сцене”.
* При дубликате возвращать структурированную ошибку (например `DuplicateNodeIdError(id, occurrences)`), без автопочинки.
* В `decodeSceneDocument` и импорте из `SceneSnapshot` удалить локальные проверки уникальности, заменить на вызов `SceneBuilder`.
  **Критерии приёмки:**
* И JSON, и `SceneSnapshot` с дублями `NodeId` всегда дают одну и ту же ошибку.
* В доменной модели дубликатов быть не может.

---

### ☑ 3) Сделать “ровно один фон” обязательным инвариантом (строго, без автопочинки)

**Что делаем:** запрещаем >1 фонового слоя как ошибку входных данных.
**Почему:** автопочинка скрывает повреждение данных и порождает непредсказуемость (особенно для интерактивности/хит-теста). Строгий отказ предотвращает “тихие” ошибки.
**Где:** `scene_builder.dart` (структурная проверка); упрощение логики в `scene_codec.dart` и `document.dart`.
**ТЗ:**

* В `canonicalizeAndValidate` проверить: фоновых слоёв 0 или 1, иначе `MultipleBackgroundLayersError(count)`.
* Убрать (или выключить) “нормализацию множества фонов” в других местах: все пути должны идти через `SceneBuilder`.
  **Критерии приёмки:**
* Любая попытка загрузить/создать сцену с 2+ фонами завершается контролируемой ошибкой.

---

### ☑ 4) Ввести каноническую форму: фон (если есть) всегда в нулевом слое

**Что делаем:** нормализуем порядок слоёв в одном месте после прохождения проверок.
**Почему:** единая каноническая форма убирает “размазанную” по коду логику перестановок и снижает риск ошибок в хит-тесте/отрисовке/индексации.
**Где:** `scene_builder.dart`; удалить/минимизировать `_txnCanonicalizeSnapshotLayers` в `document.dart`.
**ТЗ:**

* После проверки “фон не более 1” выполнить канонизацию:

  * если фон есть и он не на позиции 0 — переместить его в 0, сохранив относительный порядок остальных слоёв.
* Все остальные канонизации порядка (если есть) также делать только тут.
  **Критерии приёмки:**
* После `SceneBuilder` фон (если есть) всегда в индексе 0.

---

### ☐ 5) Усилить модель слоёв типами: убрать `isBackground: bool`

**Что делаем:** заменяем булев флаг на разные типы слоёв.
**Почему:** “недопустимое состояние нельзя выразить типами” — это архитектурная защита от возврата проблемы “несколько фонов”.
**Где:** модель слоёв (все места с `isBackground`), сериализация `lib/src/serialization/scene_codec.dart`, сборка `scene_builder.dart`.
**ТЗ:**

* Ввести типы:

  * `BackgroundLayer`
  * `ContentLayer`
* Изменить `Scene/Document` на структуру:

  * `BackgroundLayer? background`
  * `List<ContentLayer> layers`
* Обновить сериализацию/десериализацию под новые типы.
  **Критерии приёмки:**
* В доменной модели невозможно иметь два background-слоя.

---

### ☑ 6) Ввести единые числовые пределы и проверку диапазонов при построении модели

**Что делаем:** задаём контракт допустимых значений координат/масштабов/размеров и проверяем его на входе.
**Почему:** защищает от падений (переполнения/`RangeError`) и от деградации поведения на повреждённых данных.
**Где:** `scene_builder.dart` (проверки); `scene_spatial_index.dart` (см. задачу 8); `scene_codec.dart` (см. задачу 9).
**ТЗ:**

* Завести константы в одном месте (например `lib/src/core/scene_limits.dart`):

  * `coordMin = -1e7`, `coordMax = 1e7`
  * `scaleMin = 1e-4`, `scaleMax = 1e4`
  * (при наличии) пределы для размеров/радиусов/толщин
  * `schemaVersionMin/Max` (по реально поддерживаемым версиям)
* В `canonicalizeAndValidate` проверять все числовые поля узлов/трансформаций на эти пределы.
* При выходе за пределы — возвращать ошибку `OutOfRangeError(fieldPath, value, min, max)`.
  **Критерии приёмки:**
* В доменной модели значения всегда в рамках оговорённых лимитов.

---

### ☑ 7) Сделать обязательные инварианты “всегда включены” (не только в debug)

**Что делаем:** переводим критичные проверки из ассертов/отладочных инвариантов в обязательный `validateCore`.
**Почему:** иначе release-сборка продолжает принимать плохие данные и ошибки “всплывают” в неожиданных местах.
**Где:** `scene_builder.dart` + текущие `scene_invariants.dart`.
**ТЗ:**

* Реализовать `validateCore()` и вызывать его внутри `canonicalizeAndValidate` всегда.
* Оставить `validateDeep()` только для тестов/диагностики (не влияет на корректность контракта).
* Удалить зависимость корректности от `assert`.
  **Критерии приёмки:**
* Все критичные инварианты проверяются в release при любом входе.

---

### ☐ 8) Сделать пространственный индекс устойчивым: никаких падений на экстремальных значениях

**Что делаем:** защищаем вычисление индексов ячеек и вводим безопасный режим при невозможности индексации.
**Почему:** индекс — инфраструктурный компонент; он не должен быть точкой падения всего приложения.
**Где:** `lib/src/core/scene_spatial_index.dart`.
**ТЗ:**

* Перед вычислением `_cellIndexFor` гарантировать, что координаты уже в допустимых лимитах (задача 6). Дополнительно:

  * если при вычислении индекса всё же возникает исключение — индекс помечается “невалиден”, а запросы выполняются линейным обходом по узлам (fallback).
* Добавить явное поле состояния индекса: `isValid`.
  **Критерии приёмки:**
* Набор тестов с экстремальными координатами не приводит к исключениям.

---

### ☑ 9) Жёстко стандартизировать парсинг целых чисел из JSON и ошибки формата

**Что делаем:** любое некорректное число в JSON должно давать контролируемую ошибку формата, без сырых исключений и без потери точности.
**Почему:** сейчас преобразования `num -> int` потенциально дают `RangeError`/потери точности и “дырки” в обработке ошибок.
**Где:** `lib/src/serialization/scene_codec.dart`.
**ТЗ:**

* Переписать `_requireInt`:

  * принимать только значения, которые являются целыми **без потери точности**,
  * проверять диапазон (задача 6),
  * любые ошибки преобразовывать в `SceneJsonFormatException` с путём до поля.
* Аналогично стандартизировать `_requireDouble`, если есть критичные поля.
  **Критерии приёмки:**
* Некорректный JSON никогда не выбрасывает сырые `RangeError/TypeError`, только `SceneJsonFormatException`.

---

### ☑ 10) Гарантировать симметрию сериализация ↔ десериализация через общий шлюз

**Что делаем:** перед кодированием документ проходит `validateCore`, а при декодировании используется тот же конвейер `SceneBuilder`.
**Почему:** это устраняет класс “закодировали → не можем обратно принять” и фиксирует единый контракт.
**Где:** `lib/src/serialization/scene_codec.dart`.
**ТЗ:**

* `decodeSceneDocument` строит доменную модель только через `SceneBuilder.buildFromJson`.
* `encodeSceneDocument` перед кодированием вызывает `validateCore()` (или `SceneBuilder` в режиме “уже доменная модель”, если вы так оформите).
* Документировать, что сериализация выдаёт JSON в канонической форме (фон в 0 и т.п.).
  **Критерии приёмки:**
* “Туда-обратно” тесты проходят (задача 12).

---

### ☐ 11) Убрать лишние выделения памяти в горячих геттерах контроллера

**Что делаем:** прекращаем создавать новый набор на каждом чтении `selectedNodeIds`.
**Почему:** постоянные выделения в UI-цикле увеличивают нагрузку на сборщик мусора и ухудшают отзывчивость.
**Где:** `lib/src/controller/scene_controller.dart`.
**ТЗ:**

* Хранить `UnmodifiableSetView` как поле и обновлять его только при изменении selection.
* Геттер возвращает эту оболочку, без `Set.unmodifiable(...)` на каждом вызове.
  **Критерии приёмки:**
* При повторных чтениях без изменения selection не происходит новых выделений.

---

### ☑ 12) Закрепить архитектурные гарантии тестами: “туда-обратно” + плохие входы + согласованность входов

**Что делаем:** вводим тесты, которые ловят именно классы проблем.
**Почему:** без тестов регрессии неизбежны при следующей доработке сериализации/модели.
**Где:** тестовый пакет проекта.
**ТЗ:**

* Добавить тесты:

  1. `doc -> encode -> decode` эквивалентность (с учётом канонизации).
  2. Ошибка на дубликаты `NodeId` (и для JSON, и для `SceneSnapshot`).
  3. Ошибка на 2+ фоновых слоя.
  4. Ошибка на выход за числовые лимиты.
  5. Устойчивость пространственного индекса (нет падений, fallback включается).
  6. Согласованность: один и тот же “сырой” документ через JSON и snapshot даёт одинаковый результат/ошибку.
     **Критерии приёмки:**
* Тесты падают при любой попытке вернуть “мягкий” путь импорта или ослабить инварианты.

---

### ☑ 13) Документация публичного контракта (инварианты, канонизация, ошибки)

**Что делаем:** описываем правила, чтобы пользователи API не создавали некорректные `SceneSnapshot`.
**Почему:** это снижает поток “плохих” входов и уменьшает необходимость диагностики.
**Где:** README/док-комментарии к публичным типам (`SceneSnapshot`, `SceneBuilder`, сериализация).
**ТЗ:**

* Явно описать:

  * `NodeId` уникален в пределах сцены;
  * фон не более одного;
  * фон (если есть) всегда в позиции 0 после импорта;
  * допустимые числовые диапазоны;
  * перечень основных ошибок и когда они возникают.
    **Критерии приёмки:**
* Контракт можно понять без чтения внутреннего кода.

---
