language: russian

## Цель плана

Устранить класс дефектов в отрисовке и расчётах геометрии: **дорогие вычисления выполняются один раз и переиспользуются**, а **границы (bounds) считаются единообразно** для отсечения, выделения и рисования (включая учёт толщины обводки). Исключить визуальные артефакты (мигание у краёв, пропадание обводки) и снизить нагрузку на процессор/память при сценах с `Path`.

---

## План задач (самодостаточный, без развилок)

### ☑ 1) Ввести единый кэш геометрии для `NodeSnapshot` (вариант A)

**Что делаем:** добавляем компонент `RenderGeometryCache`, который хранит предвычисленную геометрию узлов по `NodeId`.
**Почему:** сейчас геометрия (особенно `Path`) пересчитывается многократно за кадр, а существующий кэш в `PathNode` не работает, потому что `PathNode` создаётся временно в painter.
**Где:** новый файл `lib/src/render/render_geometry_cache.dart`; использование в `lib/src/render/scene_painter.dart`.
**ТЗ:**

* Создать класс `RenderGeometryCache` со следующими обязанностями:

  * `GeometryEntry get(NodeSnapshot node)` — вернуть предвычисления для узла.
  * Внутри хранить `Map<NodeId, GeometryEntry>` и “ключ валидности” для каждой записи.
* `GeometryEntry` должен содержать минимум:

  * `Rect localBounds` (обязательно, с учётом обводки)
  * `Rect worldBounds` (обязательно, `transform.applyToRect(localBounds)`)
  * для `PathNodeSnapshot`: `Path localPath` (обязательно)
* “Ключ валидности” (чтобы понять, надо ли пересчитать) должен включать все поля, влияющие на геометрию:

  * для всех узлов: `node.transform` (для worldBounds), `node.opacity` не влияет на геометрию — не включать
  * для прямоугольника: `size`, `strokeWidth`, наличие/отсутствие `strokeColor` (или логический флаг “strokeEnabled”)
  * для пути: `svgPathData`, `fillRule`, `strokeWidth`, наличие/отсутствие `strokeColor`
  * для текста/изображений: размеры/параметры, которые участвуют в bounds (если есть в модели)
* Кэш должен предоставлять метод `invalidateAll()` (на изменение глобальных параметров, например масштаб/камера, если это влияет на вычисления).
  **Критерии приёмки:**
* В `ScenePainterV2` отсутствуют повторные вычисления `Path` и `getBounds()` для одного и того же узла в пределах одного кадра (см. задачи 2–4).

---

### ☑ 2) Перевести расчёт bounds в painter на `RenderGeometryCache`

**Что делаем:** `_nodeBoundsWorld(...)` перестаёт строить геометрию сам и берёт `worldBounds` из кэша.
**Почему:** сейчас `_nodeBoundsWorld` для `Path` повторно парсит и строит путь, что даёт двойную работу и несогласованность правил.
**Где:** `lib/src/render/scene_painter.dart`, метод `_nodeBoundsWorld(...)`.
**ТЗ:**

* Добавить поле `final RenderGeometryCache _geometryCache;` в `ScenePainterV2` и инициализировать в конструкторе.
* В `_nodeBoundsWorld(NodeSnapshot node)`:

  * убрать ветвления, которые строят `Path`/`Rect` вручную;
  * вернуть `_geometryCache.get(node).worldBounds`.
* Убедиться, что `worldBounds` уже учитывает канонические `localBounds` и transform.
  **Критерии приёмки:**
* `_nodeBoundsWorld` не вызывает `_buildPathNode`, `parseSvgPathData`, `buildLocalPath`, `getBounds()`.
* Подтверждено тестами: `test/render/scene_painter_bounds_contract_test.dart`, `test/render/scene_painter_test.dart`.

---

### ☑ 3) Перевести отрисовку `PathNodeSnapshot` на кэшированный `Path`

**Что делаем:** `_drawPathNode(...)` использует `localPath` из кэша вместо пересборки через временный `PathNode`.
**Почему:** текущий подход обнуляет пользу кэша `PathNode` и парсит SVG-путь повторно.
**Где:** `lib/src/render/scene_painter.dart`, метод `_drawPathNode(...)` и вспомогательные методы.
**ТЗ:**

* В `_drawPathNode(Canvas canvas, PathNodeSnapshot node, ...)`:

  * получить `entry = _geometryCache.get(node)`;
  * использовать `entry.localPath` как локальный путь (уже центрированный по правилам модели);
  * убрать вызовы `_buildPathNode(node).buildLocalPath(...)`.
* Удалить `_buildPathNode(...)` из painter (или сделать приватным только для миграции и удалить после перевода всех мест).
  **Критерии приёмки:**
* Отрисовка путей не вызывает `parseSvgPathData` напрямую или косвенно через временный `PathNode`.
* Подтверждено контрактами и регресс-тестами: `test/render/scene_painter_bounds_contract_test.dart`, `test/render/scene_painter_test.dart`.

---

### ☐ 4) Унифицировать правила расчёта `localBounds` с учётом толщины обводки (и выключенной обводки)

**Что делаем:** `RenderGeometryCache` вычисляет `localBounds` для каждой фигуры единообразно и обязательно учитывает `strokeWidth/2`, если обводка включена.
**Почему:** текущие bounds в painter не учитывают обводку, что даёт неправильное отсечение и “мигание” у краёв.
**Где:** `lib/src/render/render_geometry_cache.dart` (новый), удаление дублей в `scene_painter.dart`.
**ТЗ:**

* Для `RectNodeSnapshot`:

  * базовый `Rect` = центрированный прямоугольник по `size`;
  * если обводка включена (`strokeColor != null` и `strokeWidth > 0`) → инфлировать на `strokeWidth / 2`;
  * сохранить как `localBounds`.
* Для `PathNodeSnapshot`:

  * `localPath` строится один раз;
  * `Rect` = `localPath.getBounds()`;
  * если обводка включена → инфлировать на `strokeWidth / 2`;
  * сохранить как `localBounds`.
* Для остальных типов узлов:

  * определить правила `localBounds` по имеющимся полям (текст/изображение/линия и т.д.), но без копирования логики в painter: только в кэше.
    **Критерии приёмки:**
* Узлы с большой обводкой не пропадают/не мигают при приближении к краю экрана при панорамировании.

---

### ☐ 5) Сделать выделение/рамку/хит-область (если используется bounds) опираться на те же `worldBounds`

**Что делаем:** все места, где нужны bounds для визуализации или логики, используют `RenderGeometryCache` как источник истины.
**Почему:** иначе снова появится “две геометрии” и расхождение правил.
**Где:** `lib/src/render/scene_painter.dart` (отрисовка выделения/ручек, если там используются bounds) и другие модули, где берутся bounds.
**ТЗ:**

* Найти все участки, где вычисляются bounds/прямоугольники узла для:

  * рисования рамки выделения,
  * отрисовки ручек трансформации,
  * условного рисования (видим/не видим),
  * любых подсказок/оверлеев.
* Заменить вычисления на `geometryCache.get(node).worldBounds` (или derived от него).
  **Критерии приёмки:**
* Выделение соответствует фактической видимой фигуре и не “отстаёт” от отрисовки.

---

### ☐ 6) Добавить ранний выход для сетки: не записывать `Picture`, когда сетка выключена

**Что делаем:** `SceneStaticLayerCacheV2.draw(...)` не создаёт `_gridPicture`, если `enabled == false`.
**Почему:** сейчас есть лишняя запись картинки при выключенной сетке — это чистая лишняя работа.
**Где:** `lib/src/render/scene_painter.dart`, `SceneStaticLayerCacheV2.draw(...)`.
**ТЗ:**

* Переставить проверку `enabled` так, чтобы при `enabled == false` метод завершался до построения ключа/перезаписи `_gridPicture`.
* При выключении сетки сбросить `_gridPicture` и `_key`, чтобы не держать память.
  **Критерии приёмки:**
* При `gridEnabled == false` нет вызовов `_recordGridPicture(...)`.

---

### ☐ 7) Тесты/проверки производительности и корректности геометрии (регрессии)

**Что делаем:** добавляем тестовый контур, который защищает от возврата проблемы “двойные вычисления пути” и “bounds без stroke”.
**Почему:** без тестов рефакторинг painter быстро вернёт те же дефекты.
**Где:** тестовый пакет проекта (юнит + интеграционные/золотые кадры, если есть).
**ТЗ:**

* Тест “Path не парсится дважды за кадр”:

  * инструментировать `RenderGeometryCache` счётчиком перестроений `localPath` и проверять, что при одном `paint` на один `NodeId` перестроение ≤ 1.
* Тест “Bounds учитывают обводку”:

  * создать узел с большим `strokeWidth`, расположить у края viewport, убедиться, что он не отсечён преждевременно (проверка по `worldBounds` и/или снимок рендера).
* Тест “Сетка выключена — нет записи picture”:

  * инструментировать вызовы `_recordGridPicture` или проверить, что `_gridPicture` остаётся `null` при `enabled=false`.
    **Критерии приёмки:**
* Тесты падают при возврате ручного пересчёта пути в painter или при удалении инфляции bounds на `strokeWidth/2`.

---

### ☐ 8) Очистка: удалить устаревшие вспомогательные функции в painter, которые больше не используются

**Что делаем:** убираем `_buildPathNode(...)` и прочие дублирующие геометрию функции из `ScenePainterV2`.
**Почему:** наличие “второго пути” расчётов рано или поздно снова приведёт к рассинхронизации.
**Где:** `lib/src/render/scene_painter.dart`.
**ТЗ:**

* Удалить `_buildPathNode` и любые функции, которые строят геометрию узлов вне `RenderGeometryCache`.
* Оставить в painter только:

  * применение transform к canvas,
  * выбор `Paint`,
  * вызовы рисования на основе кэшированной геометрии.
    **Критерии приёмки:**
* В проекте нет второго места, где рассчитываются `localBounds`/`worldBounds` для тех же узлов.

---
