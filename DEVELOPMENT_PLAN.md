1. **[Закрыто] Можно разрушить инварианты `allNodeIds` / `nodeIdSeed` через публичный API транзакции**

   * **Суть:** наружу вы отдали “бухгалтерию идентификаторов” (`writeNewNodeId`, `writeRegister/UnregisterNodeId`, `writeRebuildNodeIdIndex`). Эти вызовы могут менять `workingNodeIds` и `nodeIdSeed` **без изменения самой сцены**. При фиксации это приводит к рассинхрону “сцена ↔ индекс id”, а иногда — к повторному использованию id.
   * **Где:**

     * Публичный контракт: `lib/src/public/scene_write_txn.dart:18–22`
     * Генерация/учёт id: `lib/src/controller/txn_context.dart:48–56`
     * Коммит пишет `_store.allNodeIds` и `_store.nodeIdSeed` даже когда сцена не менялась: `lib/src/controller/scene_controller.dart:223–237`
     * Отдельный неприятный случай: если **нет изменений состояния**, но есть сигналы, коммит проходит по ветке `!hasStateChanges && hasSignals` и **вообще не записывает** `allNodeIds/nodeIdSeed` (т.е. “резервирование id” теряется): `scene_controller.dart:193–201`.
   * **Чем опасен:**

     * `allNodeIds` может содержать id, которых нет в документе (логическая порча индекса).
     * `nodeIdSeed` может “убежать” вперёд без реальных узлов или, наоборот, “откатиться” между транзакциями → **повторные id** и трудно воспроизводимые ошибки уникальности/вставок/удалений/сериализации.

2. **[Закрыто] Сигналы публикуются до того, как стор обновлён (наблюдатель видит “старое” состояние после “нового” события)**

   * **Суть:** при фиксации транзакции вы сначала отправляете события сигналов, а только потом обновляете `_store` (сцену/выделение/ревизии).
   * **Где:** `lib/src/controller/scene_controller.dart`

     * Ветка “сигналы без состояния”: `writeFlushBuffered` раньше `_store.commitRevision` (`195` → `197`).
     * Ветка “есть изменения состояния”: `writeFlushBuffered` на `220`, а `_store.*` обновляется на `229–237`.
   * **Чем опасен:**

     * Подписчик `signals.listen(...)`, который читает `controller.snapshot`/`selectedNodeIds`/`commitRevision`, может увидеть **старую** сцену и старые ревизии, хотя пришёл сигнал “после фиксации”.
     * Это классический источник “призрачных” багов: порядок “событие → состояние” нарушен.

3. **[Частично закрыто] Все ключевые потоки событий сделаны синхронными (`sync: true`) → реэнтерабельность и падения на “вложенной записи”**

   * **Суть:** доставка событий выполняется прямо внутри стека `write(...)`. Из-за вашего запрета вложенных `write(...)` любая “реактивная” логика (получил событие → дописал) падает.
   * **Где:**

     * Сигналы: `lib/src/input/slices/signals/signals_slice.dart:6–8` (`StreamController.broadcast(sync: true)`)
     * Запрет вложенных записей: `lib/src/controller/scene_controller.dart:113–116` + сброс флага только в `finally` (`138–140`)
     * Похожая проблема в интерактивных событиях: `_InteractiveEventDispatcher` тоже `sync: true` (`lib/src/interactive/scene_controller_interactive.dart:55–58`).
   * **Чем опасен:**

     * Любой обработчик событий, который вызовет `controller.write(...)`, получит исключение `Nested write(...) calls are not allowed.`
     * Плюс это усиливает проблему №2: синхронное событие может прийти, пока фиксация ещё не завершена.

4. **[Закрыто] Данные событий (списки id и карты “полезной нагрузки”) изменяемые и разделяются между подписчиками**

   * **Суть:** в событиях вы отдаёте обычные `List`/`Map`, причём `payload` вообще пробрасывается как есть. В широковещательном потоке один подписчик может изменить объект события, и другие подписчики увидят изменённые данные.
   * **Где:**

     * Модель события: `lib/src/input/slices/signals/signal_event.dart:15–29` (`List<NodeId>`, `Map<String,Object?>?`)
     * Отправка сигналов: `lib/src/input/slices/signals/signals_slice.dart:33–41`

       * `nodeIds: List.of(...)` — копия, но **изменяемая**
       * `payload: signal.payload` — **без копии/защиты**
     * Аналогично в интерактивных действиях: `lib/src/interactive/scene_controller_interactive.dart:54–82` (`nodeIds` копируются, но изменяемы; `payload` без “заморозки”).
   * **Чем опасен:**

     * Невоспроизводимые эффекты “то есть payload, то его нет/он другой” в зависимости от порядка обработчиков.
     * Сложные баги при логировании/аналитике/побочных действиях, где событие считается “снимком факта”.

5. **[Закрыто] Нормализация выделения ломает смысл `onlySelectable: false` (контракт API становится “полуработающим”)**

   * **Суть:** публичное API позволяет выбрать “всё, включая невыбираемые”, но на фиксации нормализация всё равно выкидывает узлы с `isSelectable == false`.
   * **Где:**

     * Выбор “всех” с параметром: `lib/src/controller/scene_writer.dart:180–197` + политика `onlySelectable`: `lib/src/core/selection_policy.dart:7–16`
     * Нормализация на коммите: `lib/src/model/document.dart:633–47` (условие включает `node.isSelectable`)
     * Запуск нормализации: `lib/src/controller/scene_controller.dart:157–171`
   * **Чем опасен:**

     * Внутри транзакции выделение одно, после фиксации — другое.
     * Пользователь API получает “скрытую” модификацию результата и непредсказуемое поведение инструментов, которые полагаются на этот режим.

6. **[Закрыто] Публичные writer-методы допускают `NaN/Infinity` и другие невалидные числа (нормализация это не закрывает)**

   * **Суть:** `writeGridCellSize` и `writeCameraOffset` записывают значения без проверок на конечность (`isFinite`) и допустимые диапазоны. Нормализация сетки исправляет только “меньше минимума при включённой сетке”, но не `NaN/Infinity`.
   * **Где:**

     * Запись без валидации: `lib/src/controller/scene_writer.dart:60–85`
     * Нормализация сетки ограниченная: `lib/src/model/document.dart:71–78` (проверка `< kMinGridCellSize`)
   * **Чем опасен:**

     * `NaN/Infinity` быстро разъедают геометрию, вычисления границ, индексацию и отрисовку (любой расчёт с `NaN` превращается в `NaN`).
     * Ошибки могут проявляться далеко от места записи (например, “сломалась камера/сетка/хит-тесты”).

7. **[Закрыто] `writeNodeErase` обходится без проверок “можно ли удалять” (в т.ч. логика отличается от удаления выделения)**

   * **Суть:** `writeNodeErase` удаляет узел, если он найден, без учёта `node.isDeletable` и без защиты от удаления узлов в фоновом слое (если там вообще есть узлы). При этом `writeDeleteSelection` удаляет только то, что проходит `isNodeDeletableInLayer`.
   * **Где:**

     * Удаление без политики: `lib/src/controller/scene_writer.dart:66–89`
     * Само удаление из слоя без ограничений: `lib/src/model/document.dart:46–58` (`txnEraseNodeFromScene`)
     * Контраст: “удалить выделение” с проверкой: `scene_writer.dart:248–257` + `selection_policy.dart:19–22`
   * **Чем опасен:**

     * Публичный “безопасный” контракт позволяет удалить то, что по политике не должно удаляться.
     * Это может ломать инварианты документа/инструментов (особенно если есть узлы, которые задуманы как неудаляемые).

8. **[Закрыто] Двойное клонирование сцены на транзакцию при изменениях (скорее производительность, но может стать проблемой на больших документах)**

   * **Суть:** сцена копируется при первом изменении в транзакции и ещё раз при фиксации. Это надёжно для иммутабельности снаружи, но дорого.
   * **Где:**

     * Первый клон: `lib/src/controller/txn_context.dart:27–33`
     * Второй клон на коммите: `lib/src/controller/scene_controller.dart:223–225`
   * **Чем опасен:**

     * На больших сценах даст заметные просадки по памяти/времени на каждое изменение.
     * Может маскировать “побочные ожидания” внутри кода (кто-то считает, что копия одна).

Если хочешь, дальше можно зафиксировать “цель исправлений” (какой контракт вы хотите):

* **События всегда после фиксации и после завершения `write(...)`**, без права писать из обработчика; или
* **События асинхронные и можно писать из обработчика** (тогда надо аккуратно определить правила повторной записи и порядка событий).
