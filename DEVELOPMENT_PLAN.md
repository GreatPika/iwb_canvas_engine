
# План 2 (самодостаточный, без развилок)

**Цель плана:** устранить выявленные выше проблемы так, чтобы (а) класс ошибок “реюз id ломает кеши” был убран архитектурно, (б) каноническая форма сцены стала одинаковой для всех входов, (в) не было скрытых деградаций производительности и “невыбираемых” узлов.

---

1. [x] **Ввести “версию экземпляра узла” и использовать её в кешах, завязанных на `id`**
   **Закрывает проблему:** (1) коллизии кеша при повторном использовании `id` (и предотвращает аналогичные ошибки в будущих кешах).
   **Локализация:**

* `lib/src/core/nodes.dart` (база `SceneNode`)
* `lib/src/public/snapshot.dart` (база `NodeSnapshot`)
* `lib/src/model/document.dart` (`txnNodeFromSpec`, `txnNodeFromSnapshot`, `txnNodeToSnapshot`)
* `lib/src/render/scene_painter.dart` (`SceneStrokePathCacheV2` и любые кеши, где ключ — `id`)
* при необходимости: `lib/src/serialization/scene_codec.dart` (добавление поля в JSON)
  **ТЗ:**
* Добавить в `SceneNode` поле `instanceRevision` (целое, ≥ 1), которое **назначается один раз при создании узла** и больше не меняется.
* Добавить в `NodeSnapshot` поле `instanceRevision` (целое, по умолчанию `0` для обратной совместимости).
* При создании узла из `NodeSpec` и при вставке узла из внешнего снимка:

  * если `snapshot.instanceRevision <= 0`, присвоить новое значение из монотонного счётчика `nextInstanceRevision` (хранить в `V2Store`).
* При экспорте сцены в снимок (`txnNodeToSnapshot`) всегда записывать реальное `instanceRevision`.
* Обновить `SceneStrokePathCacheV2`: кешировать по ключу `(node.id, node.instanceRevision, node.pointsRevision)`.

  * То есть хранить записи в `LinkedHashMap<(NodeId, int instanceRevision), Entry>` либо сделать составной ключ-структуру.
* Покрыть тестами:

  * создать штрих `id = "A"`, отрендерить, удалить, создать новый штрих **с тем же id**, но другими точками → убедиться, что отрисовалась новая геометрия, а не старая.
  * сценарий “удаление и повторная вставка в рамках одного сеанса записи” (одной транзакции) также не должен брать старый кеш.

2. [ ] **Унифицировать инварианты фонового слоя для всех входов (снимок и JSON) через обязательную канонизацию**
   **Закрывает проблему:** (2) разные канонические формы сцены и “неидемпотентный” круговой прогон через JSON.
   **Локализация:**

* `lib/src/model/document.dart` (`txnSceneFromSnapshot`)
* `lib/src/model/scene_value_validation.dart` (`sceneValidateSnapshotValues`)
* `lib/src/serialization/scene_codec.dart` (encode/decode)
* `lib/src/core/background_layer_invariants.dart`
  **ТЗ:**
* Принять единое правило внутренней модели: **в документе всегда ровно один фоновый слой и он всегда на индексе 0**.
* В `txnSceneFromSnapshot` после построения слоёв **всегда** вызывать `canonicalizeBackgroundLayerInvariants(layers, ...)`, чтобы:

  * при отсутствии фонового слоя он вставлялся,
  * при неверном порядке он перемещался в начало.
* В `encodeScene(SceneSnapshot)` перед сериализацией также приводить `snapshot.layers` к канонической форме (внутренне, без изменения исходного объекта снимка): добавить фоновый слой при отсутствии, переместить при неверном порядке.
* В `sceneValidateSnapshotValues` оставить ограничение “не больше одного фонового слоя”, но после канонизации гарантировать “ровно один” уже на уровне документа/JSON (т.е. на выходе из импорта/кодека всегда будет один).
* Тесты:

  * снимок без фонового слоя → импорт → экспорт → повторный импорт: структура стабильна (ровно один фоновый слой).
  * JSON без фонового слоя (если допускается) → декодирование → кодирование → декодирование: структура стабильна.

3. [x] **Исправить буферизацию сигналов на линейную по числу сигналов**
   **Закрывает проблему:** (3) квадратичная деградация при большом числе сигналов в одном цикле записи.
   **Локализация:** `lib/src/input/slices/signals/signals_slice.dart`
   **ТЗ:**

* Заменить реализацию `writeBufferSignal` на добавление в изменяемый список без пересоздания:

  * `_bufferedSignals.add(signal)`;
  * при `writeTakeCommitted` возвращать `List.unmodifiable(_bufferedSignals)` и делать `_bufferedSignals.clear()`.
* Сохранить порядок сигналов (как добавлялись).
* Тест: сгенерировать 10k сигналов, убедиться, что время/память растут линейно, порядок сохранён.

4. [x] **Сделать попадание по `PathNode` устойчивым при невозвратимом преобразовании**
   **Закрывает проблему:** (4) “невыбираемые” пути при вырожденном/почти вырожденном преобразовании.
   **Локализация:** `lib/src/core/hit_test.dart` (`hitTestNode`, ветка `PathNode`)
   **ТЗ:**

* Если `transform.invert() == null`, выполнять запасной вариант попадания:

  * считать попаданием `candidateBoundsWorld.contains(worldPoint)` (с учётом существующего `hitPadding`, который уже добавляется на уровне `nodeHitTestCandidateBoundsWorld`).
* Не менять поведение для корректно обратимых преобразований.
* Тест: путь с преобразованием, которое делает матрицу необратимой (например, масштаб 0 по одной оси), должен выделяться хотя бы по габаритам.

---
