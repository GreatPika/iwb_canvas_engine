# Архитектурная стабилизация iwb_canvas_engine: выверенный план v3 

## Исходные цели и принципы, которые уже заложены в библиотеке

В текущей архитектуре уже видны два правильных «несущих» решения, на которые стоит опереться и довести до логического завершения:

Первое — **транзакционная запись**: все изменения состояния проходят через безопасный интерфейс `SceneWriteTxn`, а ядро контроллера запрещает вложенные транзакции (защита от «само-вызовов» во время записи). Это соответствует инвариантам про «мутации только через write/txn» и «безопасный публичный контракт транзакций». 

Второе — **разделение состояния и эффектов**: документация явно фиксирует, что уведомления перерисовки/слушателей планируются *после фиксации транзакции* через очередь микрозадач и «склеиваются» в пределах одного тика цикла событий. Это уже близко к «функциональное ядро + императивная оболочка», просто «замыкание» ещё не доведено до 100%. 

Отсюда целевая мета-цель v3: **сделать невозможными целые классы багов конструктивно**, так чтобы локальные «вылезло тут и там» перестали появляться, потому что *не останется архитектурных обходов*.

## Сопоставление вашего плана с текущим кодом репозитория

Ваш план в целом попадает в реальную структуру кода: упомянутые узкие места действительно существуют именно там, где вы их описали (ядро контроллера, writer, конверсия snapshot↔scene, инварианты, интерактивные события). 

При этом важно зафиксировать, что **часть ваших пунктов уже фактически реализована** (или реализована иначе):

* Уведомления `ChangeNotifier` в ядре уже не вызываются «внутри фиксации» напрямую: механизм устроен через отложенное уведомление (планирование после транзакции) и отдельный буфер `V2RepaintSlice`. 
* Сигналы ядра (`signals`) уже организованы как широковещательный поток и публикуются после фиксации транзакции, а события сигналов «замораживаются» (неизменяемые списки/полезная нагрузка) через общий механизм неизменяемых коллекций.
* Неизменяемость событий действий (`ActionCommitted`) и их полезной нагрузки также уже обеспечена (+ есть тесты на «заморозку»).

Но есть и **существенные расхождения/дыру, которые ваш план правильно целится закрыть, однако в текущей базе они ещё не закрыты полностью**:

* Вход `writeDocumentReplace(SceneSnapshot)` действительно собирает сцену напрямую через нейтральный `txnSceneFromSnapshot(snapshot)` и затем делает `txnAdoptScene`, что открывает путь «принести внутренне испорченную сцену» в хранилище.
* Сбор идентификаторов узлов в индексы (`allNodeIds`) идёт через `Set`, что по определению «схлопывает» дубликаты и поэтому **не может** обнаружить «двойной NodeId внутри сцены». 
* Интерактивные потоки `actions` и `editTextRequests` всё ещё создаются с синхронной доставкой (`sync: true`), то есть обработчики выполняются прямо в стеке вызова эмиттера. 
* Числовые «предохранители» для части публичных входов writer’а реализованы выборочно (камера/сетка проверяются), но **трансформы/смещения** для узлов/выделения и значительная часть полей `NodeSpec`/`NodePatch` пока не защищены на уровне границы.

## Текущие архитектурные дыры, которые реально порождают «локальные баги»

Ниже — именно «дыры уровня архитектуры», то есть такие места, где *по конструкции* можно породить некорректность или нежелательный порядок эффектов.

### Эффект «перерисуйся» можно случайно «выпустить наружу» даже при откате транзакции

В ядре есть публичный вход `requestRepaint()`. Сейчас он не различает «мы внутри write» и «мы снаружи write»: он помечает потребность в перерисовке и тут же пытается запланировать уведомление. 

Архитектурная проблема здесь не в том, что уведомление выполняется мгновенно (оно всё равно будет отложено), а в том, что **сам факт «публикации эффекта» происходит ещё до того, как известно, успешна ли транзакция**. Это создаёт класс багов: «транзакция упала → состояние не поменялось, но снаружи пришёл сигнал перерисоваться/слушатель сработал».

Ваш план правильно формулирует требование: *эффекты должны быть буфером транзакции и должны откатываться вместе с транзакцией*.

### Импорт сцены через initialSnapshot и writeDocumentReplace не замкнут на строгую валидацию

Конверсия `txnSceneFromSnapshot(SceneSnapshot)` в модели сейчас является «тупым» конструктором: она создаёт `Scene`/`Layer`/`SceneNode` без строгих проверок чисел, уникальности идентификаторов, корректности `svgPathData` и т.п. 

Это нормально для части внутренних путей, но критично опасно для **границ**, через которые внешние данные попадают в `_store.sceneDoc`:

* конструктор `SceneControllerV2(initialSnapshot: ...)` (вход библиотеки),
* замена документа `writeDocumentReplace(...)` (вход библиотеки).

На стороне JSON-кодека строгая проверка есть (числа конечны, правила сетки/палитры, уникальность id, проверка `svgPathData`, канонизация фона). Но это другой канал, и он не перекрывает «ручные» snapshot-входы. 

### Индекс nodeId и инварианты хранилища не ловят «дубликаты id внутри сцены»

Сейчас `txnCollectNodeIds` возвращает `Set<NodeId>`. Это означает: при наличии двух узлов с одним `id` «внутренняя порча структуры сцены» **не обнаруживается автоматически** ни сбором индекса, ни проверкой «индекс равен сборке из сцены» (потому что и там, и там `Set`).

Это именно архитектурная дыра: пока не появится явная проверка «найти дубликаты», библиотека будет уязвима к странным эффектам (патч по id обновит «первый попавшийся», хит-тест, выделение и т.п. станут недетерминированными).

### Синхронная доставка интерактивных событий — источник реэнтерабельности «в обход» ядра

Ядро уже устроено сравнительно безопасно: «write → выход из write → эффекты». Но интерактивная оболочка всё ещё создаёт потоки действий и запросов редактирования с синхронной доставкой (`StreamController.broadcast(sync: true)`).

Даже если сегодня эти события эмитятся «после write», синхронность остаётся **открытым капканом** для будущих правок (или для редких путей), где эмиссия может оказаться в середине сложного алгоритма. Ваше требование «закрыть класс багов» означает: *синхронных широковещательных потоков в публичных эффектах быть не должно*.

## Целевые контракты и инварианты v3, которые делают баги невозможными «по конструкции»

Ниже — «контракты уровня системы», которые стоит сделать истинными. Это то, что в идеале надо написать в `ARCHITECTURE.md` и обеспечить тестами/инвариантами.

Контракт эффектов:  
Любой внешний наблюдатель (слушатель `ChangeNotifier`, подписчик сигналов, подписчик действий/запросов редактирования) **никогда не выполняется в стеке `write(...)`**. Публикация эффектов происходит только после:
1) успешной фиксации состояния в `_store`,  
2) выхода из write (флаг write-состояния сброшен),  
3) затем — строго определённая публикация эффектов.

Этот контракт уже частично описан в архитектурном документе (про уведомления после фиксации) и должен быть доведён до закрытия всех каналов. 

Контракт состояния хранилища:  
Любая сцена, оказавшаяся в `_store.sceneDoc`, удовлетворяет минимальному «ядру корректности»:
* нет дубликатов `NodeId` в структуре слоёв и узлов;
* максимум один фоновый слой, и если он есть — он на индексе `0` (как зафиксировано в архитектуре);
* ключевые числовые параметры, влияющие на геометрию/математику/хит-тесты, конечны и в допустимых диапазонах (по тем же правилам, что и JSON-валидатор). 

Контракт границ ввода:  
Все публичные входы, которые могут занести числа/геометрию/идентификаторы в систему (`NodeSpec`, `NodePatch`, `Transform2D`, `Offset`, `SceneSnapshot` для initial/replace), валидируются **в одном месте** и **одними и теми же правилами**, без расхождения между сериализацией и runtime. fileciteturn69file1L1-L1 fileciteturn69file2L1-L1 fileciteturn45file3L1-L1

Контракт атомарности (в отладке и в CI):  
Если проверка инвариантов падает, `_store` остаётся неизменным (никаких «полу-обновлений»). Это прямо соответствует инварианту про атомарность фиксации транзакций.

## План работ v3: конкретные изменения, которые замыкают все дыры

Ниже — скорректированный план, который учитывает реальное состояние кода репозитория и закрывает именно «дыры архитектуры», а не «латки». Я буду сознательно считать допустимыми поломки публичного интерфейса там, где это делает систему принципиально более строгой (вы это разрешили).

### Сведение всех эффектов к единой фазе публикации и устранение утечек repaint

Цель: сделать repaint полноценным «буфером эффекта транзакции» и гарантировать отсутствие любых уведомлений при откате.

- [x] **Запрет “раннего выпуска repaint” из `requestRepaint()` во время транзакции**  
   Изменить `SceneControllerV2.requestRepaint()` так, чтобы:
   * если транзакция идёт — только `writeMarkNeedsRepaint()` и *ничего больше* (не “забирать” флаг и не планировать уведомление),
   * если транзакции нет — вести себя как раньше (планировать уведомление).  
   Это закрывает класс «вызвали requestRepaint внутри write → транзакция упала → уведомление всё равно пришло». 

- [x] **Единая публикация эффектов в конце `write(...)`**  
   Перестроить внутренний протокол `SceneControllerV2.write` так, чтобы после успешной фиксации выполнялась единая функция “опубликовать эффекты”, где:
   * сначала ставятся в очередь доставки сигналы,
   * затем (и только затем) планируется `notifyListeners` (если repaint нужен).  
   Это формализует «функциональное ядро: посчитали изменения и эффекты; императивная оболочка: опубликовали эффекты» без размазывания логики по разным местам. 

- [x] **Порядок “сигналы → notify” сделать гарантированным на уровне очереди микрозадач**  
   Сейчас порядок критичен, потому что и сигналы, и уведомление идут через очередь микрозадач. Чтобы *предсказуемо* сначала доставлялись сигналы, а затем уведомлялись слушатели, нужно гарантировать, что постановка сигналов в очередь происходит до планирования `notifyListeners`. 

- [x] **Новые тесты на класс багов “repaint при откате”**  
   Добавить тест на уровне ядра (логично рядом с текущими тестами контроллера), который:
   * подписывается на `addListener`,
   * делает `write(() { controller.requestRepaint(); throw ... })`,
   * убеждается, что уведомления не было.  
   Текущие тесты уже хорошо покрывают «откат не меняет состояние» и «нет сигналов», но этот конкретный канал эффекта ещё не закрыт. 

### Единый валидатор значений и строгий конструктор Snapshot -> Scene

Цель: замкнуть корректность состояния на границах и убрать обходные пути через нейтральную конверсию.

- [x] **Вынести общие правила проверки чисел/геометрии в отдельный внутренний модуль**  
   Сейчас строгие проверки живут внутри JSON-кодека как набор приватных функций. Нужно сделать единый набор «примитивов проверки» (конечность, неотрицательность, >0, [0..1], проверка `svgPathData`) так, чтобы:
   * JSON-кодек продолжал бросать `SceneJsonFormatException`,
   * runtime-валидатор бросал `ArgumentError` (или свой тип ошибки входных данных). 

- [x] **Сделать один строгий конструктор `Snapshot -> Scene` для store**  
   В плане не должно быть двух режимов конверсии. `txnSceneFromSnapshot(...)` становится строгим конструктором для границы хранилища и обязан:
   * проверять уникальность `NodeId` (явным поиском дубликатов, не через `Set`),
   * проверять/канонизировать правило фонового слоя: не более одного, и если он есть — на индексе 0 (без автодобавления фонового слоя при отсутствии),
   * валидировать/нормализовать сетку и палитру по контракту хранилища,
   * валидировать ключевые числовые поля узлов и `svgPathData`. 

- [x] **Переписать сериализацию на прямую работу из `Scene`**  
   `encodeScene(...)` должен строить JSON напрямую из `Scene`, без шага `Snapshot -> Scene`.

- [x] **Замкнуть все “входы сцены” на строгий конструктор**  
   После ужесточения конструктора нужно обязательно перевести на него:
   * конструктор `SceneControllerV2(initialSnapshot: ...)`,
   * `SceneWriter.writeDocumentReplace(...)` (а значит и `SceneControllerV2.writeReplaceScene`). 

- [x] **Тесты на запрет “внутренне порченого” initial/replace**  
   Добавить тесты, которые подают:
   * snapshot с дубликатами id,
   * snapshot с двумя фоновыми слоями,
   * snapshot с `Transform2D` содержащим `NaN/Infinity`,
   * snapshot с невалидным `svgPathData`,
   * snapshot с пустой палитрой,  
   и проверяют, что:
   * выбрасывается понятная ошибка входных данных,
   * старое состояние хранилища не меняется (для replace). 

### Полное замыкание “числовых предохранителей” на границах write-операций

Цель: чтобы инвариант “writer отвергает невалидные числовые входы” стал истинным не точечно (как сейчас для сетки/камеры), а для всех полей, способных отравить математику. 

- [x] **Валидация на `txnNodeFromSpec` и `txnApplyNodePatch`**  
   И `NodeSpec`, и `NodePatch` — это публичный вход в систему (частый, массовый). Сейчас они конвертируются в узлы/мутации без строгой проверки чисел. 

   Нужно:
   * для `Spec`: проверять поля так же строго, как это делает JSON-декодер (конечность, диапазоны, точки/толщины, `svgPathData` и т.д.),
   * для `Patch`: проверять только присутствующие поля (`PatchField.value`), разумеется теми же правилами.

   Отдельно: `opacity` сделана строгой на write-границе (`[0,1]`) для единообразного fail-fast контракта. 
- [x] **Закрыть прямой обход через writer-методы, принимающие `Transform2D`/`Offset`**  
   Минимальный набор «дыр» прямо сейчас:
   * `writeNodeTransformSet`,
   * `writeSelectionTransform`,
   * `writeSelectionTranslate`. fileciteturn69file5L1-L1  

   Для них нужно добавить явные проверки `isFinite` и выбрасывать `ArgumentError.value(...)` при невалидных входах (это важнее, чем молча «санитизировать», потому что иначе ошибка проявится далеко от источника).

- [x] **Тесты на отказ для невалидных Transform2D/Offset**  
   В существующих тестах уже проверяется отказ для камеры/сетки. Этот же стиль тестов должен быть расширен на трансформы/смещения. 
### Усиление инвариантов и реальная атомарность фиксации (в отладке и CI)

Цель: чтобы инварианты были не «описаны на бумаге», а действительно обеспечивали архитектурную безопасность.

1) **Проверять инварианты *до* записи в `_store`**  
   Сейчас инварианты вызываются вокруг фиксации, но ключевой принцип атомарности требует: сначала посчитать кандидатное состояние и проверить его, и только потом присвоить `_store.*`. 

   Важно: это нужно сделать и:
   * для ветки «есть изменения состояния»,
   * и для ветки «только сигналы» (там тоже меняется `commitRevision`).

2) **Расширить store-инварианты до ловли сценовых порч**  
   В `scene_invariants.dart` сейчас проверяются важные вещи (индекс id соответствует сборке, seed выведен из сцены, нормализация выделения, камера/сетка), но отсутствует явное обнаружение дубликатов id и проверка фонового слоя. 
   Добавить:
   * проход по всем узлам и поиск `NodeId`, встречающихся > 1 раза,
   * проверку «фоновых слоёв ≤ 1; если 1 — индекс 0».  

   Это стоит держать как отладочную страховку (и страховку CI), даже если строгий конструктор snapshot-входов уже «закрывает дыру» на границе.

3) **Тест на “инварианты падают → _store не меняется”**  
   Это обязательный тест для настоящей атомарности: искусственно создать сценарий, где `writeDocumentReplace` пытается принести некорректную сцену, и убедиться, что после исключения:
   * `scene/selection/revisions/epoch` не поменялись,
   * не было внешних эффектов (ни сигналов, ни notify). 

### Унификация доставки интерактивных событий и отказ от синхронной широковещательной доставки

Цель: убрать последний публичный «канал синхронных эффектов», чтобы реэнтерабельность больше не возвращалась через интерактивный слой.

1) **Перевести `actions` и `editTextRequests` на асинхронную доставку**  
   В `_InteractiveEventDispatcher` заменить создание потоков с `sync: true` на стандартное (асинхронное) создание широковещательных потоков. 

2) **Обновить тесты интерактивного контроллера**  
   Сейчас множество тестов ожидают, что `actions`/`editTextRequests` обновятся сразу после вызова методов. После перехода на асинхронную доставку нужно будет системно добавлять `await pumpEventQueue()` перед проверками. 
3) **Обновить публичную документацию контракта событий**  
   Внешние приложения часто опираются на «когда приходит событие». После изменения синхронности нужно явно зафиксировать в `ARCHITECTURE.md` и (если есть) в руководстве API: события интерактивных действий — только после выхода в очередь событий. 

### Опциональные улучшения, которые не закрывают “дыру корректности”, но снимают будущие риски

1) **Кэш `snapshot` по идентичности сцены**  
   Сейчас получение `snapshot` приводит к полной реконструкции снимка из `Scene`. Кэш по `identical(_store.sceneDoc, cachedScene)` безопасен при вашей модели “клон при первой мутации” и снижает нагрузку без архитектурного риска. 

2) **Случайное тестирование транзакций (минимальный генератор сценариев)**  
   Добавить тест, который выполняет случайные последовательности операций writer’а и после каждой фиксации проверяет инварианты (или отсутствие нарушений). Это даёт “страховку от редких комбинаций” ещё до релиза. 

## Критерии завершения v3 и миграционные последствия

Считать стабилизацию v3 завершённой стоит только тогда, когда одновременно истинны все пункты ниже (это и есть «архитектурное совершенство» в рамках выбранной модели):

1) В библиотеке нет ни одного пути, где внешний эффект может вырваться наружу при откате транзакции: ни через сигналы, ни через уведомления, ни через интерактивные потоки. 

2) `SceneSnapshot` на входе initial/replace не способен привести к внутренне некорректному `_store.sceneDoc`: дубликаты id, множественный фоновый слой, невалидные числа в геометрии/трансформах, битый `svgPathData`, некорректная палитра — всё это либо отвергается, либо (только где это оправдано) нормально канонизируется по зафиксированным правилам. 

3) Любой публичный write-вход, который принимает числа/геометрию (`NodeSpec`, `NodePatch`, `Transform2D`, `Offset`) либо валиден, либо немедленно и диагностируемо отвергнут (с понятным именем поля). 

4) В отладке/CI фиксация транзакции атомарна: падение инварианта не оставляет `_store` в полу-обновлённом состоянии. 

5) Интерактивные события больше не доставляются синхронно; тесты и документация обновлены под новую модель доставки. 
Миграционные последствия (то, что можно смело считать допустимым “сломом интерфейса”, раз вы это разрешили):

* Появятся новые исключения “входные данные некорректны” там, где раньше библиотека молча принимала плохие числа/структуру и деградировала позже. Это полезный слом: он переносит ошибку к источнику.
* События `actions`/`editTextRequests` станут асинхронными: внешним приложениям, которые полагались на «немедленность», понадобится адаптация (обычно это один `await`/переезд логики в обработчик события). 
