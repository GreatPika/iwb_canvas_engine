
---

## План: закрыть верхнеуровневые риски (память, производительность, инварианты)

### A. `RenderGeometryCache` — рост памяти при удалении узлов

* [x] Открыть `lib/src/render/render_geometry_cache.dart` и подтвердить: `_entries` не ограничен по размеру и не очищается при исчезновении узлов.
* [x] Выбрать стратегию ограничения памяти (одну):

  * [x] **LRU-вытеснение**: `LinkedHashMap` + `maxEntries` + удаление самых старых.
  * [ ] **Очистка по “живым” id**: на кадр/коммит удалять записи, которых нет в текущей сцене.
  * [ ] **Перенос владения в `SceneViewV2`**: хранить geometry-кэш как остальные кэши и очищать централизованно.
* [x] Реализовать выбранную стратегию.
* [x] Добавить минимальный тест/проверку:

  * [x] сценарий “создать много узлов → удалить → проверить, что размер кэша не растёт без ограничений”.
* [x] Добавить в документацию (внутренний комментарий): где живёт кэш, кто владеет и когда он очищается.

---

### B. `RenderGeometryCache` — ключ валидности stroke включает список точек

* [x] В `lib/src/render/render_geometry_cache.dart` найти `_buildValidityKey` для `StrokeNodeSnapshot`.
* [x] Убрать `strokeNode.points` из ключа валидности (оставить `pointsRevision`, толщину, transform и прочие скалярные поля).
* [x] Проверить, что `pointsRevision` действительно увеличивается при изменении точек (по коду вставки/патча/коммита штриха).
* [x] Добавить тест/проверку производительности/кэш-попаданий:

  * [x] два последовательных `snapshot` без изменения конкретного stroke не должны приводить к пересчёту геометрии этого stroke.

---

### C. Жизненный цикл кэшей в `SceneViewV2`: geometry vs остальные

* [x] В `lib/src/view/scene_view.dart` зафиксировать текущую схему:

  * [x] кэши `static/text/stroke/pathMetrics` создаются/передаются и очищаются в `SceneViewV2State`.
  * [x] `RenderGeometryCache` создаётся/живёт внутри `ScenePainterV2`.
* [x] Принять решение по архитектуре владения (одно):

  * [x] **Унифицировать**: передавать `geometryCache` в `ScenePainterV2` из `SceneViewV2State`.
  * [ ] **Оставить внутри painter**, но обязать: `maxEntries` + предсказуемая очистка при “существенных событиях”.
* [x] Реализовать выбранный вариант.
* [x] Добавить краткое описание правил владения ресурсами в руководство/комментарии (кто чистит, когда чистит, как избежать утечек).

---

### D. `V2SpatialIndexSlice` — риск “навсегда линейный поиск”

* [ ] Открыть `lib/src/input/slices/spatial_index/spatial_index_slice.dart`.
* [ ] Найти ветку: `if (!_index!.applyIncremental(...)) { if (!_index!.isValid) { ... } ... }`.
* [ ] Исправить поведение при `!_index.isValid`:

  * [ ] вызвать `_invalidate()` (или эквивалентный сброс `_index`), чтобы следующий запрос гарантированно пересобрал индекс.
* [ ] Добавить тест/проверку:

  * [ ] смоделировать “индекс стал невалидным” → следующий запрос кандидатов должен пересобрать индекс (или явно зафиксировать иной контракт).

---

### E. Инварианты и защита от регрессий

* [ ] Для каждого изменения выше добавить/обновить инвариант/комментарий рядом с кодом:

  * [x] “geometry-кэш ограничен по размеру/очищается при …”
  * [x] “валидность stroke определяется `pointsRevision`, список точек в ключ не входит”
  * [ ] “невалидный spatial index всегда приводит к пересборке, а не вечному fallback”
* [x] Прогнать существующие проверки:

  * [x] `tool/check_guardrails.dart`
  * [x] `tool/check_import_boundaries.dart`
  * [x] `tool/check_invariant_coverage.dart`
* [x] Добавить одну “регрессионную” проверку на уровне тестов:

  * [x] “после серии вставок/удалений память/размеры кэшей остаются ограниченными”.

---

### F. Быстрый контрольный прогон (после правок)

* [ ] Вручную проверить сценарий:

  * [ ] рисование большого числа штрихов → стирание → повторное рисование → отсутствие деградации по памяти и отзывчивости.
* [ ] Проверить, что смена документа (`replaceScene`) корректно сбрасывает кэши и не оставляет “хвостов”.

---

Если хочешь, могу сразу превратить этот план в **минимальный набор правок по файлам** (что менять и как), но без “лишних” улучшений — только то, что закрывает пункты A–D.
