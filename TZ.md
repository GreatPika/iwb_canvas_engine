# Техническое задание для Codex

## Flutter-движок холста (аналог роли konva.js)

### Версия

v1.0

---

## 1) Цель

Сделать библиотеку (пакет Dart/Flutter), которая предоставляет приложению **движок сцены**:

* хранение и управление объектами на холсте (узлы, слои, группы);
* отрисовку на Flutter `Canvas`;
* обработку ввода (мышь/палец/стилус) и логику взаимодействия с объектами;
* операции выделения, перемещения, поворота на 90°, отражения (flip), удаления;
* инструменты аннотаций (ручка, маркер, прямая линия, ластик);
* фон (сетка и цвет);
* прокрутку рабочей области через «камеру» (минимум по X);
* сериализацию/десериализацию сцены в JSON.

Цель — закрыть **ровно функции движка холста**, без предметной логики приложения.

---

## 2) Границы ответственности

### 2.1 Входит в работу

* Модель сцены и её сериализация.
* Отрисовка сцены и слоёв.
* Ввод и события.
* Проверка попадания по объектам.
* Выделение (одиночное и групповое рамкой).
* Перемещение.
* Поворот на 90° (по/против часовой).
* Отражение по вертикальной оси (flip).
* Удаление выбранного.
* Очистка сцены.
* Рисование аннотаций: ручка, маркер, прямая линия.
* Ластик для аннотаций.
* Фон: сетка и цвет.
* Камера: смещение (минимум X, допускается хранить и Y для простоты математики).

### 2.2 Не входит в работу

* Меню, панели, окна, список ресурсов, загрузка ассетов из каталога.
* Сохранение в БД/файлы приложения, история undo/redo как готовая функция.
* Готовые «рабочие области» и их правила.
* Генераторы случайных объектов, ограничения «можно добавить только один раз» и т. п.

---

## 3) Нефункциональные требования

* Движок работает офлайн и не требует сети.
* Движок не зависит от UI приложения (кроме виджета-хоста сцены).
* Код на Dart, совместим с Flutter stable.
* Предсказуемость: изменения состояния происходят дискретно на границах действий (см. события действий).

---

## 4) Структура поставки (Deliverables)

1. Пакет `iwb_canvas_engine`:

* `core/` — модель сцены, типы, математика.
* `render/` — отрисовка.
* `input/` — ввод и распознавание действий.
* `serialization/` — JSON.

1. `example/` приложение:

* переключение режимов Move/Draw;
* добавление тестовых объектов;
* выделение рамкой;
* rotate/flip/delete/clear;
* ручка/маркер/линия/ластик;
* фон (сетка/цвет);
* камера (прокрутка по X).

1. Тесты:

* юнит-тесты математики трансформаций и хит-теста;
* тесты сериализации;
* (желательно) визуальные «золотые» тесты отрисовки нескольких эталонных сцен.

---

## 5) Термины

* **Сцена** — корневой объект, содержащий слои, камеру и настройки фона.
* **Слой** — упорядоченный список узлов, отрисовываемых вместе.
* **Узел** — объект на сцене: картинка, текст, прямоугольник, штрих и т. п.
* **Группа** — логическое объединение выбранных узлов для операций.
* **Камера** — параметры отображения: смещение (и при необходимости масштаб; масштаб в этом ТЗ не требуется).
* **Проверка попадания** — определение узла, на который указывает пользователь.
* **Рамка выделения** — прямоугольник, которым выбирают несколько узлов.

---

## 6) Публичный интерфейс (API) — требования к форме

Движок должен предоставлять:

* контроллер сцены (управление моделью, команды);
* виджет-хост для отрисовки и ввода;
* события для приложения.

**Важно:** API должен быть достаточным, чтобы приложение не обращалось к внутренним классам движка.

---

## 7) События движка

Движок обязан сообщать приложению о:

* изменениях сцены (для обновления UI);
* запросе редактирования текста;
* границах действий (начало/завершение), чтобы приложение могло строить undo/redo и логи действий.

Событие «действие завершено» (commit) обязано срабатывать для:

* завершения перетаскивания;
* завершения рисования штриха;
* завершения рисования прямой линии;
* выполнения команд rotate/flip/delete/clear;
* завершения выделения рамкой.

---

# 8) Функциональные требования (с критериями приёмки)

## A. Сцена, слои, порядок

### REQ-A1 — Сцена содержит слои и настройки

**Описание:** Сцена хранит список слоёв (упорядоченный), параметры камеры и фон.

**Критерии приёмки:**

* AC-A1-1: Можно создать сцену, добавить слой, добавить узлы в слой и отрисовать.
* AC-A1-2: Сериализация сцены включает слои, узлы, камеру и фон.

---

### REQ-A2 — Порядок отрисовки (z-порядок)

**Описание:** Узлы отрисовываются в порядке списка (последний — сверху). Слои тоже имеют порядок.

**Критерии приёмки:**

* AC-A2-1: При перекрытии двух узлов верхним считается узел с большим индексом в слое.
* AC-A2-2: При перекрытии узлов из разных слоёв верхним считается слой с большим индексом.

---

## B. Узлы: базовые свойства

### REQ-B1 — Общие свойства узла

**Описание:** Каждый узел имеет:

* `id: String` (уникальный в пределах сцены);
* `type` (перечисление типов узлов);
* `position (x,y)`;
* `rotationDeg`;
* `scaleX`, `scaleY`;
* `opacity (0..1)`;
* `isVisible`;
* `isSelectable`;
* `isLocked` (запрет перемещения);
* `isDeletable`;
* `isTransformable` (rotate/flip).

**Критерии приёмки:**

* AC-B1-1: Узел с `isVisible=false` не отрисовывается и не участвует в проверке попадания.
* AC-B1-2: Узел с `isSelectable=false` нельзя выделить ни нажатием, ни рамкой.
* AC-B1-3: Узел с `isLocked=true` не перемещается перетаскиванием.
* AC-B1-4: Узел с `isTransformable=false` игнорирует rotate/flip.

---

## C. Типы узлов (минимальный набор)

### REQ-C1 — ImageNode (картинка)

**Описание:** Узел отображает растровое изображение, заданное через `ImageProvider` или заранее загруженный `ui.Image`.

**Критерии приёмки:**

* AC-C1-1: Картинка рисуется в ожидаемых размерах и позиции.
* AC-C1-2: Поворот и отражение применяются визуально корректно.
* AC-C1-3: Проверка попадания работает по ограничивающему прямоугольнику картинки.

---

### REQ-C2 — TextNode (текст)

**Описание:** Узел отображает текст. Редактирование текста выполняется приложением; движок лишь сообщает о запросе редактирования.

**Критерии приёмки:**

* AC-C2-1: Текст рисуется и перемещается как обычный узел.
* AC-C2-2: Двойное нажатие по тексту вызывает событие `EditTextRequested(nodeId)`.
* AC-C2-3: Обновление текста через API немедленно отражается на экране.
* AC-C2-4: Проверка попадания работает по ограничивающему прямоугольнику текста.

---

### REQ-C3 — StrokeNode (штрих: ручка/маркер)

**Описание:** Узел хранит полилинию (последовательность точек в координатах сцены) и стиль (толщина, цвет, непрозрачность).

**Критерии приёмки:**

* AC-C3-1: Штрих рисуется непрерывно при перемещении указателя.
* AC-C3-2: Маркер визуально отличается от ручки (минимум: другая толщина и/или непрозрачность).
* AC-C3-3: Проверка попадания по штриху учитывает толщину (допуск не меньше половины толщины).

---

### REQ-C4 — LineNode (прямая линия)

**Описание:** Узел хранит две точки (start/end) и стиль.

**Критерии приёмки:**

* AC-C4-1: Линия строится между двумя точками.
* AC-C4-2: Проверка попадания работает с учётом толщины.

---

### REQ-C5 — RectNode (прямоугольник)

**Описание:** Нужен минимум для служебных целей: рамка выделения и тестовые фигуры в `example/`.

**Критерии приёмки:**

* AC-C5-1: Прямоугольник отображается корректно и участвует в выделении.

---

## D. Камера (прокрутка)

### REQ-D1 — Камера со смещением

**Описание:** Камера задаёт смещение отображаемой области относительно координат сцены. Требуется минимум горизонтальное смещение (X). Разрешается хранить и Y для простоты вычислений.

**Критерии приёмки:**

* AC-D1-1: При изменении `cameraOffset.x` объекты визуально сдвигаются и становятся доступными при прокрутке.
* AC-D1-2: Проверка попадания учитывает камеру: нажимаем на объект после прокрутки — выбирается именно он.
* AC-D1-3: Рисование штриха в режиме Draw даёт точки в координатах сцены (не экрана).

---

## E. Ввод и распознавание действий

### REQ-E1 — Унифицированные события указателя

**Описание:** Поддержать down/move/up, single tap, double tap. Работает для мыши, пальца, стилуса.

**Критерии приёмки:**

* AC-E1-1: На desktop и mobile действия одинаковы по смыслу (нажатие/перетаскивание/рисование).
* AC-E1-2: Двойное нажатие распознаётся стабильно (порог времени и расстояния фиксирован в настройках и может быть задан).

---

### REQ-E2 — Захват указателя при перетаскивании

**Описание:** Если начато перетаскивание узла, движение продолжается до отпускания, даже если указатель вышел за его границы.

**Критерии приёмки:**

* AC-E2-1: Начав перетаскивание внутри узла, можно вывести указатель за пределы узла, и узел продолжает перемещаться.

---

## F. Проверка попадания по объектам

### REQ-F1 — Выбор верхнего узла

**Описание:** При нажатии выбирается верхний узел (по порядку слоёв и узлов), который допускает выделение.

**Критерии приёмки:**

* AC-F1-1: При перекрытии двух объектов выбирается тот, что сверху.
* AC-F1-2: Узлы с `isSelectable=false` пропускаются при проверке попадания.

---

## G. Выделение

### REQ-G1 — Одиночное выделение

**Описание:** Нажатие по узлу выделяет его. Нажатие в пустое место снимает выделение.

**Критерии приёмки:**

* AC-G1-1: Нажатие по узлу делает его выбранным и показывает визуальную индикацию.
* AC-G1-2: Нажатие по пустому месту очищает выделение.

---

### REQ-G2 — Групповое выделение рамкой

**Описание:** В режиме Move пользователь может протянуть прямоугольник выделения. Выбираются все узлы, пересекающиеся с рамкой по их ограничивающему прямоугольнику (правило фиксируется как основное).

**Критерии приёмки:**

* AC-G2-1: Во время протягивания рамка видна на экране.
* AC-G2-2: После отпускания рамки выделены все узлы, которые пересеклись с рамкой.
* AC-G2-3: После выделения рамкой группа ведёт себя как единый объект для операций Move/Rotate/Flip/Delete.

---

## H. Перемещение

### REQ-H1 — Перемещение одного узла

**Описание:** В режиме Move выбранный узел можно перетаскивать.

**Критерии приёмки:**

* AC-H1-1: При перетаскивании узла меняется его позиция.
* AC-H1-2: Если `isLocked=true`, позиция не меняется.
* AC-H1-3: По отпусканию генерируется событие `ActionCommitted(type=move)` с перечнем затронутых узлов.

---

### REQ-H2 — Перемещение группы

**Описание:** Если выбрано несколько узлов, перетаскивание перемещает их на одинаковую дельту.

**Критерии приёмки:**

* AC-H2-1: Все узлы группы меняют позицию на одинаковое смещение.
* AC-H2-2: Событие `ActionCommitted(type=move)` содержит все `nodeId` группы.

---

## I. Поворот и отражение

### REQ-I1 — Поворот на 90°

**Описание:** Команда поворачивает выбранный узел или группу на 90° по или против часовой стрелки.

**Критерии приёмки:**

* AC-I1-1: Один вызов меняет `rotationDeg` на +90 или -90.
* AC-I1-2: Четыре поворота возвращают визуально в исходное положение.
* AC-I1-3: Для группы поворот происходит вокруг центра объединённой рамки выделения.
* AC-I1-4: Генерируется `ActionCommitted(type=rotate)`.

---

### REQ-I2 — Отражение (flip) по вертикальной оси

**Описание:** Команда отражает выбранный узел/группу зеркально относительно вертикальной оси.

**Критерии приёмки:**

* AC-I2-1: Два отражения возвращают визуально в исходное положение.
* AC-I2-2: Для группы отражение выполняется вокруг вертикальной оси центра группы.
* AC-I2-3: Генерируется `ActionCommitted(type=flip)`.

---

## J. Удаление и очистка

### REQ-J1 — Удаление выбранного

**Описание:** Команда удаляет выбранный узел/группу.

**Критерии приёмки:**

* AC-J1-1: Удалённые узлы исчезают из модели и с экрана.
* AC-J1-2: Узлы с `isDeletable=false` не удаляются.
* AC-J1-3: Генерируется `ActionCommitted(type=delete)`.

---

### REQ-J2 — Очистка сцены

**Описание:** Команда очищает сцену от узлов всех пользовательских слоёв (кроме слоя фона).

**Критерии приёмки:**

* AC-J2-1: После `clear()` на сцене нет узлов (кроме фоновых).
* AC-J2-2: Генерируется `ActionCommitted(type=clear)`.

---

## K. Рисование (аннотации)

### REQ-K1 — Режимы Move и Draw

**Описание:** Движок имеет режимы:

* Move — выделение/перемещение/команды;
* Draw — рисование аннотаций.

**Критерии приёмки:**

* AC-K1-1: В Draw нажатие и движение создают аннотации, но не выделяют и не перемещают узлы.
* AC-K1-2: В Move рисование не создаёт аннотации.

---

### REQ-K2 — Ручка

**Описание:** В Draw инструмент «ручка» создаёт `StrokeNode`.

**Критерии приёмки:**

* AC-K2-1: При перемещении указателя добавляются точки полилинии.
* AC-K2-2: По отпусканию создаётся один `StrokeNode` и генерируется `ActionCommitted(type=drawStroke)`.

---

### REQ-K3 — Маркер

**Описание:** В Draw инструмент «маркер» создаёт `StrokeNode` с отличающимся стилем.

**Критерии приёмки:**

* AC-K3-1: Маркер визуально отличается от ручки.
* AC-K3-2: По завершению генерируется `ActionCommitted(type=drawHighlighter)`.

---

### REQ-K4 — Прямая линия

**Описание:** В Draw инструмент «линия» создаёт `LineNode`. Поддержать два способа:

1. нажал–потянул–отпустил;
2. два нажатия: старт, затем конец.

**Критерии приёмки:**

* AC-K4-1: Оба способа создают одну прямую линию.
* AC-K4-2: По завершению генерируется `ActionCommitted(type=drawLine)`.

---

### REQ-K5 — Палитра цветов (ровно 6 по умолчанию)

**Описание:** Движок поддерживает палитру из 6 цветов для ручки/маркера/линии. Палитра настраивается через API.

**Критерии приёмки:**

* AC-K5-1: В `example/` доступно 6 цветов.
* AC-K5-2: Смена цвета влияет на следующий создаваемый штрих/линию.
* AC-K5-3: API позволяет задать произвольные 6 цветов.

---

### REQ-K6 — Ластик (только аннотации)

**Описание:** Ластик удаляет только узлы аннотаций (штрихи и линии). Минимальная реализация: при пересечении траектории ластика с узлом аннотации — удалять узел целиком.

**Критерии приёмки:**

* AC-K6-1: Ластик удаляет штрихи/линии.
* AC-K6-2: Ластик не удаляет картинки, текст и прямоугольники.
* AC-K6-3: По завершению стирания генерируется `ActionCommitted(type=erase)`.

---

## L. Фон

### REQ-L1 — Сетка (набор размеров)

**Описание:** Фон может отображать сетку. Размер клетки выбирается из набора значений.

**Критерии приёмки:**

* AC-L1-1: В `example/` доступно минимум 4 размера клетки.
* AC-L1-2: Сетка корректно двигается вместе с камерой.
* AC-L1-3: Выбранный размер сохраняется в JSON.

---

### REQ-L2 — Цвет фона (ровно 4 по умолчанию)

**Описание:** Фон может иметь один из 4 цветов по умолчанию. Набор цветов настраивается через API.

**Критерии приёмки:**

* AC-L2-1: В `example/` доступно 4 цвета.
* AC-L2-2: Выбранный цвет сохраняется в JSON.

---

## M. Сериализация

### REQ-M1 — Экспорт/импорт JSON

**Описание:** Сцена экспортируется и импортируется из JSON. Формат имеет поле `schemaVersion`.

**Критерии приёмки:**

* AC-M1-1: Экспорт → импорт → отрисовка: сцена визуально совпадает с исходной (для эталонных сцен).
* AC-M1-2: Экспорт → импорт → экспорт даёт эквивалентный JSON (допускаются различия только в порядке полей, но не в данных).
* AC-M1-3: Некорректный JSON даёт понятную ошибку и не приводит к падению.

---

## N. Отрисовка и обновления

### REQ-N1 — Инвалидация и перерисовка

**Описание:** Движок перерисовывает холст при изменении сцены/камеры/фона.

**Критерии приёмки:**

* AC-N1-1: При отсутствии изменений холст не перерисовывается постоянно.
* AC-N1-2: При рисовании и перетаскивании картинка обновляется визуально в реальном времени.

---

# 9) Тестирование

## 9.1 Юнит-тесты (обязательно)

* вычисление ограничивающих прямоугольников (bbox);
* поворот на 90° вокруг заданной точки;
* отражение относительно оси;
* преобразование координат с камерой;
* проверка попадания для прямоугольника и линии/штриха;
* сериализация/десериализация.

**Критерии приёмки:**

* AC-T1: Набор юнит-тестов покрывает все математические функции и сериализацию.

## 9.2 Визуальные тесты (желательно)

* несколько эталонных JSON-сцен → рендер → сравнение изображения.

**Критерии приёмки:**

* AC-T2: В репозитории есть минимум 3 эталонные сцены и соответствующие снимки.

---

# 10) Definition of Done

* Пакет собирается на Flutter stable.
* `example/` демонстрирует все основные сценарии.
* Все требования REQ-* выполнены и проходят проверки приёмки.
* Юнит-тесты проходят в CI.
* Есть краткая документация: как встроить виджет, как управлять сценой, как слушать события.

---

# 11) Примечания по минимальной реализации

* Для большинства узлов допускается проверка попадания по ограничивающему прямоугольнику.
* Для линий и штрихов обязателен допуск по толщине.
* Ластик на первом этапе удаляет весь узел аннотации при пересечении.

Конец документа.

---

# Appendix A — Implementation Clarifications (v1.0 Addendum)

This appendix fixes concrete implementation decisions for v1.0.

## A1) Implementation variant

**Chosen variant:** **A** — `SceneController` as the single source of truth + `CustomPaint` for rendering + `Listener` for raw pointer events.

**Rationale:** easier control over double-tap, drag, drawing, eraser, and clear “action boundaries”.

---

## A2) ImageNode JSON representation

**Decision:** JSON stores **only an image reference id**. Loading/decoding is the app responsibility.

**Minimum JSON fields for ImageNode:**

* `imageId: string` — key resolved by the app to a `ui.Image` via callback/resolver.
* `width`, `height` — rendered size in scene coordinates.
* `naturalWidth`, `naturalHeight` — optional if known (for bbox without waiting on load).

**Not stored in JSON:** `bytes`, `url`.

---

## A3) `schemaVersion`

**Decision:** `schemaVersion = 1` (fixed).

Future format changes must bump the version and use a migration **in the app** or a separate module.

---

## A4) TextNode style (minimum required)

**Required JSON fields:**

* `text: string`
* `fontSize: number` (default `24`)
* `color: string` (ARGB/HEX, e.g. `#FF000000`)
* `align: 'left'|'center'|'right'` (default `left`)
* `isBold: bool` (default `false`)
* `isItalic: bool` (default `false`)
* `isUnderline: bool` (default `false`)

**Optional:**

* `fontFamily: string` (system default if omitted)
* `maxWidth: number` (for wrapping)
* `lineHeight: number`

---

## A5) Hit-test for rotated objects

**Decision:** AABB after rotation is sufficient.

Compute the 4 rectangle corners, transform them, build the AABB, and hit-test against it.
Exact hit-test against the rotated rectangle is **not required**.

For lines/strokes, use distance-to-segment with thickness tolerance (see A8).

---

## A6) Group transforms (rotate/flip)

**Decision:** group is **not** stored. Transform applies to each selected node.

### Rotate 90°

* Compute group center `C` (center of the union AABB of the selection).
* For each node:
  * rotate its **position** around `C`;
  * update `rotationDeg` by ±90.

### Flip (vertical axis)

* Axis is the vertical line through `C.x`.
* For each node:
  * mirror its position around that axis;
  * set `scaleX = -scaleX` to preserve mirror orientation.

---

## A7) Line tool: two-tap flow

**Decision:** two-tap flow uses a timeout to avoid “hanging” state.

* On first tap: store start point and set `pendingLineStart`.
* Wait for the second tap **up to 10 seconds**.
* Cancel on:
  * timeout,
  * tool/mode change,
  * explicit cancel in example (button / Esc if present),
  * scene clear.

In `example/`, show a small start marker so users understand it is waiting for the end point.

---

## A8) Eraser trajectory and tolerance

**Decision:** eraser path is a polyline with its own thickness.

Intersection rule:

* For each eraser segment and each stroke/line segment, compute min distance between segments.
* Delete the annotation if  
  `distance <= (eraserThickness / 2 + strokeThickness / 2)`.

Default values:

* `eraserThickness = 20` (logical pixels)
* pen `strokeThickness = 3`
* highlighter `strokeThickness = 12` and `opacity ≈ 0.4`

---

## A9) Default palettes

No brand colors provided, so defaults are neutral and configurable via API.

### 6 colors for pen/highlighter/line (default)

1. Black `#FF000000`
2. Red `#FFE53935`
3. Blue `#FF1E88E5`
4. Green `#FF43A047`
5. Orange `#FFFB8C00`
6. Purple `#FF8E24AA`

### 4 background colors (default)

1. White `#FFFFFFFF`
2. Light Yellow `#FFFFF9C4`
3. Light Blue `#FFBBDEFB`
4. Light Green `#FFC8E6C9`

---

## A10) Default grid sizes

Default cell sizes (logical pixels): `10`, `20`, `40`, `80`. Configurable via API.

---

## A11) Action events (minimum)

**Required:** `ActionCommitted`.

**Optional:** `ActionStarted`.

**Not required:** `ActionUpdated`.

### `ActionCommitted` fields (required)

* `actionId: string` (unique within session)
* `type: enum`  
  (`move`, `selectMarquee`, `rotate`, `flip`, `delete`, `clear`, `drawStroke`, `drawHighlighter`, `drawLine`, `erase`)
* `nodeIds: string[]` (affected nodes; for draw: created node; for erase: deleted nodes)
* `timestampMs: int`
* `payload: map` (optional, minimal):
  * move: `{deltaX, deltaY}`
  * rotate: `{clockwise: bool}`
  * draw*: `{tool, color, thickness}`
  * erase: `{eraserThickness}`

This is sufficient because undo/redo is handled at the app level.
